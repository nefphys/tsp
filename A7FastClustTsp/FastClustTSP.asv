function [TSP_Solve_Struct] = FastClustTSP(tspData,MaxDistNum)
%% 先编写主体框架
% 后续传入聚类参数，智能算法参数，设置智能算法的选择
% tspData 数据路径
% MaxDistNum 最大可计算距离矩阵的大小 n*n, 数据量大于此值则不计算距离矩阵
% 计算TSP则不改变层数，不赋值TSP则改变层数
%算法内智能算法求解TSP最多可以计算999个点的情况
t1 = cputime;
MaxTspSize = 100;%可计算的最大规模TSP
MaxKmeans = 100;%kmeans最大K值
StdKmeans = 500;%kmeans数据集分割大小
MaxDP = 10000;%基于密度聚类的最大点集
%读取数据
%判断数据量大小，如果数据量大于某个值，则不计算distance
[Distance, City] = readfile(tspData,0);
DataLen = size(City,1); %总数据大小
ID = 1:DataLen; %ID 与CITY对应的，方便后续查找数据
if DataLen < MaxDistNum
    [Distance, City] = readfile(tspData,1);
else
    
end

%% 初始化标准结构体
std_struct = struct('inID',0,'outID',0,'set',0,'isover',0,'tsp',0,'order','0');
ANS_GROUP = std_struct;
ANS_GROUP.set = ID;

%% 主循环,可以表示层数，默认最多999层和999个数据
layer = 1; 
while(true)
    % 对结构体中的每个数据进行判断是否计算
    % 双倍内存的形式，生成一个伴生的空结构体
    ANS_GROUP_FAKE = [];
    %是否还需要计算
    isCal = 0;
    for i = 1:length(ANS_GROUP)
        tarStruct = ANS_GROUP(i);
        tempStruct = std_struct;
        %isover==0则需要继续计算，否则返回原来的结构体
        %计算之后返回的也是一个结构体数组, 如果有变化则删除原本的结构体，并拼接新的
        if tarStruct.isover == 0
            isCal = 1;
            %判断集合内点的数量，以确定是聚类还是计算TSP
            setSize = length(tarStruct.set);
            
            
            %% 简洁版本
            
            %% 原始数据就是单点集，直接返回
            if tarStruct.inID == 0 && setSize == 1
                tempStruct.inID = tarStruct.set;
                tempStruct.outID = tarStruct.set;
                tempStruct.set = tarStruct.set;
                tempStruct.isover = 1;
                tempStruct.tsp = tarStruct.set;
                tempStruct.order = '0'; %原始点就是单点集，没有计算的必要

            
            %% 原始数据只有两个点
            elseif tarStruct.inID == 0 && setSize == 2
                tempStruct.inID = tarStruct.set(1);
                tempStruct.outID = tarStruct.set(2);
                tempStruct.set = tarStruct.set;
                tempStruct.isover = 1;
                tempStruct.tsp = tarStruct.set;
                tempStruct.order = '0'; 

            
            %% 原始数据少于 MaxTspSize 指定的TSP最大规模
            elseif tarStruct.inID == 0 && setSize <= MaxTspSize && setSize > 2
                tempStruct.inID = 0;
                tempStruct.outID = 0;
                tempStruct.set = tarStruct.set;
                tempStruct.isover = 1;
                tempStruct.tsp = TSP_Solver(City(tarStruct.set,:)); %调用求解器
                tempStruct.order = '0';
                
                
            %% 聚类之后的数据，单点集
            elseif tarStruct.inID ~= 0 && setSize == 1
                tempStruct = tarStruct;
                tempStruct.isover = 1;
                tempStruct.tsp = tarStruct.set;
            
                
            %% 聚类之后的数据，两个点
            elseif tarStruct.inID ~= 0 && setSize == 2
                tempStruct = tarStruct;
                tempStruct.isover = 1;
                tempStruct.tsp = [tarStruct.inID tarStruct.outID];
            
            %% 有起点和终点，聚类过的数据，且数据规模小于指定的TSP最大规模    
            elseif tarStruct.inID ~= 0 && setSize <= MaxTspSize && setSize > 2
                %没有聚类则没有多出来的层数，只需要计算tsp和isover
                tempStruct = tarStruct;
                tempStruct.isover = 1;
                [ACS_TEMP_SOLVE]  =  ACS_SE_Solver(City(tempStruct.set,:),...
                        300, find(tempStruct.set==tempStruct.inID),...
                        find(tempStruct.set==tempStruct.outID), 0);
                    tempStruct.tsp = tempStruct.set(ACS_TEMP_SOLVE.route);
             
            %% 不管是否第一次进入，数据量都大于指定TSP求解规模
            else
                %先判断是否数据规模足够大，防止错误判断
                if(setSize <= MaxTspSize)
                    mer = '不应该进入到这里'
                end
                
                %判断聚类方式
                %赋值in out set order
                tempCity = City(tarStruct.set,:); %先读取当前城市数据
                if setSize <= MaxDP
                    tempCityDist = squareform(pdist(tempCity));
                    %传入点坐标，点之间的距离矩阵，K，中心点数
                    %cluster 一个数组，每个点对应的分类，最小为1
                    %center 中心点的id
                    Centers = ceil(setSize/MaxTspSize);
                    K = 10;
                    Clust_Ans = SnnDpc(tempCity,1:setSize,K,'AutoPick',...
                        Centers,'Distance',tempCityDist,'Ui',false);
                    Clust_Ans.center = tempCity(Clust_Ans.center,:);
                else
                    %如果点的数量大于10000，则进行kmeans聚类
                    Centers = min(MaxKmeans,ceil(setSize/StdKmeans));
                    [cidx, cc] = kmeans(tempCity,Centers);
                    Clust_Ans.cluster = cidx;
                    Clust_Ans.center = cc;
                    
                end
                
                %生成一个Centers个结构体数组
                tempStruct = repmat(std_struct,1,Centers);
                for h = 1:Centers
                    %子集应该是原本tempstruct中的项
                    tempStruct(h).set = tarStruct.set(Clust_Ans.cluster == h);
                end
                
                %如果有起点和终点指定，则找到对应的团簇，并指定起点终点
                startID = tarStruct.inID;
                endID = tarStruct.outID;
                
                startClustID = 0;
                endClustID = 0;
                
                if startID == 0 && endID == 0
                    [ACS_TEMP_SOLVE]  =  ACS_Solver(Clust_Ans.center, 300, 0);
                else
                    %查找在哪个团簇
                    for h = 1:Centers
                        
                        FSClust = ismember(startID,tempStruct(h).set);
                        if FSClust == 1
                            startClustID = h;
                            tempStruct(h).inID = startID;
                        end
                        
                        FEClust = ismember(endID,tempStruct(h).set);
                        if FEClust == 1
                            endClustID = h;
                            tempStruct(h).outID = endID;
                        end
                        
                        if startClustID ~=0 && endClustID ~= 0
                            break;
                        end
                    end
                    [ACS_TEMP_SOLVE]  =  ACS_Solver(Clust_Ans.center, 300, startClustID, endClustID, 0);
                end
                
                %对团簇的order进行赋值
                for h = 1:Centers
                    tempStruct(h).order = [num2str(layer,'%03d') ...
                        num2str(find(ACS_TEMP_SOLVE.route==h),'%03d')];
                end
                
                %寻找起点和终点，有的团簇已经有了起点或者终点
                CX1 = []; %起点团簇的坐标集
                CX2 = []; %终点团簇的坐标集
                tempStruct = [tempStruct tempStruct(1)];
                for h = 1:Centers
                    %判断第1簇是否有出点。第2簇是否有入点
                    if tempStruct(h).outID == 0 && tempStruct(h+1).inID == 0
                        %都没有指定
                        CX1 = City(tempStruct(h).set,:);
                        CX2 = City(tempStruct(h+1).set,:);
                    elseif tempStruct(h).outID ~= 0 && tempStruct(h+1).inID == 0
                        CX1 = City(tempStruct(h).outID,:); %直接指定的id
                        CX2 = City(tempStruct(h+1).set,:);
                    elseif tempStruct(h).outID == 0 && tempStruct(h+1).inID ~= 0
                        CX1 = City(tempStruct(h).set,:);
                        CX2 = City(tempStruct(h+1).inID,:);
                    else
                        CX1 = City(tempStruct(h).outID,:);
                        CX2 = City(tempStruct(h+1).inID,:);
                    end
                    
                    [minDist C1 C2] = setMinDist(CX1,CX2);
                    if size(CX1,1) ~= 1
                        tempStruct(h).outID = tempStruct(h).set(C1);
                    end
                    if size(CX2,1) ~= 1
                        tempStruct(h+1).inID = tempStruct(h+1).set(C2);
                    end       
                end
                tempStruct(1).inID = tempStruct(end).inID;
                tempStruct(end) = [];
            end   
            ANS_GROUP_FAKE = [ANS_GROUP_FAKE tempStruct];
        else
            ANS_GROUP_FAKE = [ANS_GROUP_FAKE tarStruct];
        end
        %重新赋值ans_group
        ANS_GROUP = ANS_GROUP_FAKE;
    end
    
    %终止条件，只要后面一次循环isover全部是1，即借宿
     if isCal == 0
         break;
     end
     %层数增加
    layer = layer + 1;
end

t2 = cputime;
TSP_Solve_Struct.time = t2 - t1'

%%解析路径，b


TSP_Solve_Struct.route
TSP_Solve_Struct.City
TSP_Solve_Struct.clust 
TSP_Solve_Struct.layer = layer - 1;
end




















